package test;







import java.awt.event.KeyEvent;
import java.util.ArrayList;

import javafx.scene.input.MouseEvent;

import javax.sound.sampled.LineUnavailableException;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.input.MouseEvent;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;

public class Draw2Controller {
	public Draw2View view;
	public Draw2Model model;
	public Draw2miniMap radarView;
	double distanceTraveled = 0;
	double x;
	double y;            	
	double dx = 0;
	double dy = 0;
	boolean xDirection = false;
	boolean yDirection = false;
	ArrayList<Double> timeOfChange;
	
	long time;
	
	public Draw2Controller(Draw2View v, Draw2Model m, Draw2miniMap r) throws InterruptedException 
{
		view = v;
		model = m;
		radarView = r;
		timeOfChange = new ArrayList<>();
		
	//when shift key is down, pan the canvas to new area's
		
	
	view.c.setOnMousePressed(new EventHandler<MouseEvent>()  {        	
        @Override
        public void handle(MouseEvent me) {
        	//will be useful in mouseDragged for velocity
        	x = me.getX();
        	y = me.getY();
        	time = System.currentTimeMillis();        	 
        	view.startPath(me.getX()/view.width, me.getY()/view.height); 
        	radarView.startPath(me.getX()/view.width, me.getY()/view.height); 
                        		                        
        }
    });
	
        //in the controller
	view.c.setOnMouseReleased(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent me) {            	
            	 //calculate speed and distance of the stroke(in the model)
            	
            	//would be informative to reproduce the edges in the stroke
            	//every time the stroke changes direction (+,+ -> -,-)
            	
            	model.calculateStroke(distanceTraveled,time);
            	distanceTraveled = 0;
            	//timeOfChange.forEach(a -> System.out.println("change in direction at "+a));
                
            }
        });
      
	view.c.setOnMouseDragged(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent me) {  
            	//set up relativized view coordinates
            	double viewx = me.getX()/view.width;
            	double viewy = me.getY()/view.height;            	
            	
            	//calculate distance travel
        		dx = me.getX();
        		dy = me.getY();
            	distanceTraveled += Math.abs(Math.sqrt(Math.pow((dx-x), 2)+Math.pow((dy-y), 2)));
            	
            	//calculate stroke direction
            	//set the direction travelled, calculate if there is a change in direction, set the new direction travelled
            	           	
            	//calculate change in direction 
            	//if xDirection is different than current direction, mark the time.
            	if ((x < dx) != xDirection) {
            		timeOfChange.add((double)System.currentTimeMillis()-time);
            	}
            	if((y < dy) !=yDirection) {
            		timeOfChange.add((double)System.currentTimeMillis()-time);
            	}

            	//set the direction travelled if the change is of 10 pixels or more
            	if (x < dx) {
            		xDirection = true;
            	}else {
            		xDirection = false;
            	}
            	if(y<dy) {
            		yDirection = true;
            	}else {
            		yDirection=false;
            	}            	            	            	            	
            	
            	x = dx;
            	y = dy;
            	
            	
            	
            	
            	//CALCULATE DRAG VELOCITY
            	//every 100 ms calculate a curent mouse x mouse y
            	//also figure out distance from previous x and y
            	//if the distance is bigger than 300pixels, play a 'fast' sound
            	//else play slow sound
            /*	
            	double dx = 0;
            	double dy = 0;
            	
            	//Works! doesn't quite sound realistic, need to implement the granular synthesis probably
            	if (System.currentTimeMillis() -time >= 100) {
            		time = System.currentTimeMillis();
            		dx = me.getX();
            		dy = me.getY();
            		distance = Math.sqrt(Math.pow((dx-x), 2)+Math.pow((dy-y), 2));
            		x = dx;
            		y = dy;
            		//System.out.println("distance = " +distance);
            		if (distance >= 100) {
            			//clip.start();
                    //clip.setMicrosecondPosition(0);
            		}else {
            			//clip2.start();
                        //clip2.setMicrosecondPosition(0);
            		}
                    
            		
            	}
            	//play sound synthesis
            	try {
					player.play();					
				} catch (LineUnavailableException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
            	*/

                // keep lines within rectangle

                if (view.c.getBoundsInLocal().contains(me.getX(), me.getY())) {
                	view.strokePath(viewx, viewy); 
                	view.startPath(viewx, viewy);
                
                //draw in the radarView               
                	radarView.strokePath(viewx, viewy); 
                	radarView.startPath(viewx, viewy);
                }
                
                }
        });	
//fix this up!
	/*
	view.setOnKeyPressed(new EventHandler<KeyEvent>() {
        @Override
        public void handle(KeyEvent event) {
            switch (event.getCode()) {
                case UP:    goNorth = true; break;
                case DOWN:  goSouth = true; break;
                case LEFT:  goWest  = true; break;
                case RIGHT: goEast  = true; break;
                case SHIFT: running = true; break;
            }
        }
    });*/
	}

}
